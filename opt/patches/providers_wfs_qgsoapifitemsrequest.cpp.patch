--- a/src/providers/wfs/qgsoapifitemsrequest.cpp	2022-02-18 15:06:10.000000000 +0300
+++ b/src/providers/wfs/qgsoapifitemsrequest.cpp	2022-04-07 00:39:42.000000000 +0300
@@ -13,8 +13,9 @@
  *                                                                         *
  ***************************************************************************/
 
-#include <nlohmann/json.hpp>
-using namespace nlohmann;
+// #include <nlohmann/json.hpp>
+// using namespace nlohmann;
+#include "qgsjsonutils.h"
 
 #include "qgslogger.h"
 #include "qgsoapifitemsrequest.h"
@@ -120,31 +121,39 @@
   vectorProvider.reset();
   VSIUnlink( vsimemFilename.toUtf8().constData() );
 
-  try
-  {
-    const json j = json::parse( utf8Text.toStdString() );
-    if ( j.is_object() && j.contains( "features" ) )
+    QString error;
+    const json j = QgsJsonUtils::parse( utf8Text.toStdString(), error );
+    if(!error.isEmpty())
+    {
+        mErrorCode = QgsBaseNetworkRequest::ApplicationLevelError;
+        mAppLevelError = ApplicationLevelError::JsonError;
+        mErrorMessage = errorMessageWithReason( tr( "Cannot decode JSON document: %1" ).arg( error ) );
+        emit gotResponse();
+        return;
+    }
+
+    if ( QgsJsonUtils::is_object(j) )
     {
-      const json features = j["features"];
-      if ( features.is_array() && features.size() == mFeatures.size() )
-      {
-        for ( size_t i = 0; i < features.size(); i++ )
+        const json features = j["features"];
+        if ( QgsJsonUtils::is_array(features) )
         {
-          const json &jFeature = features[i];
-          if ( jFeature.is_object() && jFeature.contains( "id" ) )
-          {
-            const json id = jFeature["id"];
-            if ( id.is_string() )
+            auto featuresA = features.ToArray();
+            if( featuresA.Size() == mFeatures.size() )
             {
-              mFeatures[i].second = QString::fromStdString( id.get<std::string>() );
+                for ( int i = 0; i < featuresA.Size(); i++ )
+                {
+                    const json &jFeature = featuresA[i];
+                    if ( QgsJsonUtils::is_object(jFeature) )
+                    {
+                        const json id = jFeature["id"];
+                        if ( id.IsValid() )
+                        {
+                            mFeatures[i].second = QString::fromStdString( id.ToString() );
+                        }
+                    }
+                }
             }
-            else if ( id.is_number_integer() )
-            {
-              mFeatures[i].second = QString::number( id.get<qint64>() );
-            }
-          }
         }
-      }
     }
 
     const auto links = QgsOAPIFJson::parseLinks( j );
@@ -152,23 +161,14 @@
                                        QStringLiteral( "next" ),
     {  QStringLiteral( "application/geo+json" ) } );
 
-    if ( j.is_object() && j.contains( "numberMatched" ) )
+    if ( QgsJsonUtils::is_object(j) )
     {
-      const auto numberMatched = j["numberMatched"];
-      if ( numberMatched.is_number_integer() )
-      {
-        mNumberMatched = numberMatched.get<int>();
-      }
+        const auto numberMatched = j["numberMatched"];
+        if ( QgsJsonUtils::is_number_integer(numberMatched) )
+        {
+            mNumberMatched = numberMatched.ToInteger();
+        }
     }
-  }
-  catch ( const json::parse_error &ex )
-  {
-    mErrorCode = QgsBaseNetworkRequest::ApplicationLevelError;
-    mAppLevelError = ApplicationLevelError::JsonError;
-    mErrorMessage = errorMessageWithReason( tr( "Cannot decode JSON document: %1" ).arg( QString::fromStdString( ex.what() ) ) );
-    emit gotResponse();
-    return;
-  }
 
-  emit gotResponse();
+    emit gotResponse();
 }
