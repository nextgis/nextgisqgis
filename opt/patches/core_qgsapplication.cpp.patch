--- a/src/core/qgsapplication.cpp	2022-02-18 15:06:10.000000000 +0300
+++ b/src/core/qgsapplication.cpp	2022-04-21 23:47:25.000000000 +0300
@@ -41,7 +41,7 @@
 #include "qgscolorschemeregistry.h"
 #include "qgspainteffectregistry.h"
 #include "qgsprojectstorageregistry.h"
-#include "qgsexternalstorageregistry.h"
+// #include "qgsexternalstorageregistry.h"
 #include "qgsrasterrendererregistry.h"
 #include "qgsrendererregistry.h"
 #include "qgspointcloudrendererregistry.h"
@@ -67,7 +67,7 @@
 #include "qgsstyle.h"
 #include "qgsprojutils.h"
 #include "qgsvaliditycheckregistry.h"
-#include "qgsnewsfeedparser.h"
+// #include "qgsnewsfeedparser.h"
 #include "qgsbookmarkmanager.h"
 #include "qgsstylemodel.h"
 #include "qgsconnectionregistry.h"
@@ -76,9 +76,9 @@
 #include "qgsfeaturestore.h"
 #include "qgslocator.h"
 #include "qgsreadwritelocker.h"
-#include "qgsbabelformatregistry.h"
+// #include "qgsbabelformatregistry.h"
 
-#include "gps/qgsgpsconnectionregistry.h"
+// #include "gps/qgsgpsconnectionregistry.h"
 #include "processing/qgsprocessingregistry.h"
 #include "processing/models/qgsprocessingmodelchildparametersource.h"
 #include "processing/models/qgsprocessingmodelchilddependency.h"
@@ -136,6 +136,21 @@
 
 #include <proj.h>
 
+#ifdef Q_OS_MAC
+static void translationPath(const QString &basePath,
+                               QList<QString> &localePaths)
+{
+    QDir baseDir(basePath);
+    QStringList filters;
+    filters << QString("ngstd_*.framework");
+    QStringList list = baseDir.entryList(filters);
+    for (const QString &subPath : list) {
+        const QString &libTrPath = basePath + "/" + subPath +
+                "/Resources/translations";
+        localePaths.append(libTrPath);
+    }
+}
+#endif // Q_OS_MAC
 
 #define CONN_POOL_MAX_CONCURRENT_CONNS      4
 
@@ -145,6 +160,9 @@
 const char *QgsApplication::QGIS_ORGANIZATION_NAME = "QGIS";
 const char *QgsApplication::QGIS_ORGANIZATION_DOMAIN = "qgis.org";
 const char *QgsApplication::QGIS_APPLICATION_NAME = "QGIS3";
+const char *QgsApplication::NGQGIS_ORGANIZATION_NAME = VENDOR;
+const char *QgsApplication::NGQGIS_ORGANIZATION_DOMAIN = VENDOR_DOMAIN;
+const char *QgsApplication::NGQGIS_APPLICATION_NAME = APP_NAME;
 QgsApplication::ApplicationMembers *QgsApplication::sApplicationMembers = nullptr;
 QgsAuthManager *QgsApplication::sAuthManager = nullptr;
 int ABISYM( QgsApplication::sMaxThreads ) = -1;
@@ -163,11 +181,11 @@
 Q_GLOBAL_STATIC( QgsStringMap, sSystemEnvVars )
 Q_GLOBAL_STATIC( QString, sConfigPath )
 
-Q_GLOBAL_STATIC( QString, sBuildSourcePath )
-#if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
-Q_GLOBAL_STATIC( QString, sCfgIntDir )
-#endif
-Q_GLOBAL_STATIC( QString, sBuildOutputPath )
+// Q_GLOBAL_STATIC( QString, sBuildSourcePath )
+// #if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
+// Q_GLOBAL_STATIC( QString, sCfgIntDir )
+// #endif
+// Q_GLOBAL_STATIC( QString, sBuildOutputPath )
 Q_GLOBAL_STATIC( QStringList, sGdalSkipList )
 Q_GLOBAL_STATIC( QStringList, sDeferredSkippedGdalDrivers )
 Q_GLOBAL_STATIC( QString, sAuthDbDirPath )
@@ -184,48 +202,95 @@
 {
   *sPlatformName() = platformName;
 
-  if ( *sTranslation() != QLatin1String( "C" ) )
+  if ( *sTranslation() != QStringLiteral( "C" ) )
   {
-    mQgisTranslator = new QTranslator();
-    if ( mQgisTranslator->load( QStringLiteral( "qgis_" ) + *sTranslation(), i18nPath() ) )
-    {
-      installTranslator( mQgisTranslator );
-    }
-    else
-    {
-      QgsDebugMsgLevel( QStringLiteral( "loading of qgis translation failed %1/qgis_%2" ).arg( i18nPath(), *sTranslation() ), 2 );
-    }
 
-    /* Translation file for Qt.
-     * The strings from the QMenuBar context section are used by Qt/Mac to shift
-     * the About, Preferences and Quit items to the Mac Application menu.
-     * These items must be translated identically in both qt_ and qgis_ files.
-     */
-    QString qtTranslationsPath = QLibraryInfo::location( QLibraryInfo::TranslationsPath );
-#ifdef __MINGW32__
-    QString prefix = QDir( QString( "%1/../" ).arg( QApplication::applicationDirPath() ) ).absolutePath();
-    qtTranslationsPath = prefix + qtTranslationsPath.mid( QLibraryInfo::location( QLibraryInfo::PrefixPath ).length() );
-#endif
-
-    mQtTranslator = new QTranslator();
-    if ( mQtTranslator->load( QStringLiteral( "qt_" ) + *sTranslation(), qtTranslationsPath ) )
-    {
-      installTranslator( mQtTranslator );
-    }
-    else
-    {
-      QgsDebugMsgLevel( QStringLiteral( "loading of qt translation failed %1/qt_%2" ).arg( qtTranslationsPath, *sTranslation() ), 2 );
+      QList<QString> localePaths;
+      localePaths.append(i18nPath());
+      #ifdef Q_OS_MAC
+        translationPath(QApplication::applicationDirPath() +
+                             "/Contents/Frameworks/", localePaths);
+        translationPath(QApplication::applicationDirPath() +
+                             "/../../Contents/Frameworks/", localePaths);
+        translationPath(QApplication::applicationDirPath() +
+                             "/../Library/Frameworks/", localePaths);
+        translationPath(QApplication::applicationDirPath() +
+                             "/../../../../Library/Frameworks/", localePaths);
+      #else
+        const QString &libTrPath = QApplication::applicationDirPath()
+                  + QStringLiteral("/../share/translations");
+        localePaths.append(libTrPath);
+      #endif // Q_OS_MAC
+
+        localePaths.append(QLibraryInfo::location(QLibraryInfo::TranslationsPath));
+
+
+    // mQgisTranslator = new QTranslator();
+    QStringList translationFilters;
+    translationFilters << QString("ngstd_*%1*").arg(*sTranslation());
+    translationFilters << QString("qt_%1*").arg(*sTranslation());
+    translationFilters << QString("qtbase_%1*").arg(*sTranslation());
+    translationFilters << QString("qgis_%1*").arg(*sTranslation());
+    translationFilters << QString("qscintilla_%1*").arg(*sTranslation());
+
+    for(const QString &localePath : localePaths) {
+        QDir localeDir(localePath);
+        QStringList libTrList = localeDir.entryList(translationFilters);
+        QgsDebugMsgLevel( QStringLiteral( "Translation path ") + localePath + QStringLiteral( " -- get translation files: "), 2);
+        for (const QString &trFileName : libTrList) {
+            QString loadFile = localeDir.absoluteFilePath(trFileName);
+            QTranslator *translator = new QTranslator;
+            if (translator->load(loadFile)) {
+                QgsDebugMsgLevel( QStringLiteral( "Loaded translation file ") +  loadFile, 2);
+                installTranslator(translator);
+                mTranslators.push_back(translator);
+            }
+            else {
+                QgsDebugMsgLevel(QStringLiteral("Loading of translation failed [") + loadFile + QStringLiteral("]"), 2);
+                delete translator;
+            }
+        }
     }
 
-    mQtBaseTranslator = new QTranslator();
-    if ( mQtBaseTranslator->load( QStringLiteral( "qtbase_" ) + *sTranslation(), qtTranslationsPath ) )
-    {
-      installTranslator( mQtBaseTranslator );
-    }
-    else
-    {
-      QgsDebugMsgLevel( QStringLiteral( "loading of qtbase translation failed %1/qt_%2" ).arg( qtTranslationsPath, *sTranslation() ), 2 );
-    }
+//     if ( mQgisTranslator->load( QStringLiteral( "qgis_" ) + *sTranslation(), i18nPath() ) )
+//     {
+//       installTranslator( mQgisTranslator );
+//     }
+//     else
+//     {
+//       QgsDebugMsgLevel( QStringLiteral( "loading of qgis translation failed %1/qgis_%2" ).arg( i18nPath(), *sTranslation() ), 2 );
+//     }
+
+//     /* Translation file for Qt.
+//      * The strings from the QMenuBar context section are used by Qt/Mac to shift
+//      * the About, Preferences and Quit items to the Mac Application menu.
+//      * These items must be translated identically in both qt_ and qgis_ files.
+//      */
+//     QString qtTranslationsPath = QLibraryInfo::location( QLibraryInfo::TranslationsPath );
+// // #ifdef __MINGW32__
+// //     QString prefix = QDir( QString( "%1/../" ).arg( QApplication::applicationDirPath() ) ).absolutePath();
+// //     qtTranslationsPath = prefix + qtTranslationsPath.mid( QLibraryInfo::location( QLibraryInfo::PrefixPath ).length() );
+// // #endif
+
+//     mQtTranslator = new QTranslator();
+//     if ( mQtTranslator->load( QStringLiteral( "qt_" ) + *sTranslation(), qtTranslationsPath ) )
+//     {
+//       installTranslator( mQtTranslator );
+//     }
+//     else
+//     {
+//       QgsDebugMsgLevel( QStringLiteral( "loading of qt translation failed %1/qt_%2" ).arg( qtTranslationsPath, *sTranslation() ), 2 );
+//     }
+
+//     mQtBaseTranslator = new QTranslator();
+//     if ( mQtBaseTranslator->load( QStringLiteral( "qtbase_" ) + *sTranslation(), qtTranslationsPath ) )
+//     {
+//       installTranslator( mQtBaseTranslator );
+//     }
+//     else
+//     {
+//       QgsDebugMsgLevel( QStringLiteral( "loading of qtbase translation failed %1/qt_%2" ).arg( qtTranslationsPath, *sTranslation() ), 2 );
+//     }
   }
 
   mApplicationMembers = new ApplicationMembers();
@@ -239,13 +304,21 @@
 {
   if ( profileFolder.isEmpty() )
   {
-    if ( getenv( "QGIS_CUSTOM_CONFIG_PATH" ) )
-    {
-      profileFolder = getenv( "QGIS_CUSTOM_CONFIG_PATH" );
-    }
-    else
+      profileFolder = QString::fromLocal8Bit( qgetenv( "QGIS_CUSTOM_CONFIG_PATH" ) );
+    if( profileFolder.isEmpty() )
     {
-      profileFolder = QStandardPaths::standardLocations( QStandardPaths::AppDataLocation ).value( 0 );
+        QString config;
+      #ifdef Q_OS_MAC
+        config = QStringLiteral("Library/Application Support");
+      #else
+        config = QStringLiteral(".config");
+      #endif
+        profileFolder = QString( "%1%2qgis%3" )
+                .arg( QDir::homePath() + QDir::separator() + config + QDir::separator())
+                .arg( QDir::separator() + QStringLiteral(VENDOR) + QDir::separator() )
+                .arg( VERSION_INT / 10000 );
+        qputenv("QGIS_CUSTOM_CONFIG_PATH", profileFolder.toUtf8());        
+    //   profileFolder = QStandardPaths::standardLocations( QStandardPaths::AppDataLocation ).value( 0 );
     }
     // This will normally get here for custom scripts that use QgsApplication.
     // This doesn't get this hit for QGIS Desktop because we setup the profile via main
@@ -284,7 +357,7 @@
     qRegisterMetaType<QgsGeometry>( "QgsGeometry" );
     qRegisterMetaType<QgsDatumTransform::GridDetails>( "QgsDatumTransform::GridDetails" );
     qRegisterMetaType<QgsDatumTransform::TransformDetails>( "QgsDatumTransform::TransformDetails" );
-    qRegisterMetaType<QgsNewsFeedParser::Entry>( "QgsNewsFeedParser::Entry" );
+    // qRegisterMetaType<QgsNewsFeedParser::Entry>( "QgsNewsFeedParser::Entry" );
     qRegisterMetaType<QgsRectangle>( "QgsRectangle" );
     qRegisterMetaType<QgsLocatorResult>( "QgsLocatorResult" );
     qRegisterMetaType<QgsProcessingModelChildParameterSource>( "QgsProcessingModelChildParameterSource" );
@@ -310,69 +383,73 @@
 
   ( void ) resolvePkgPath();
 
-  if ( ABISYM( mRunningFromBuildDir ) )
-  {
-    // we run from source directory - not installed to destination (specified prefix)
-    *sPrefixPath() = QString(); // set invalid path
-#if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
-    setPluginPath( *sBuildOutputPath() + '/' + QString( QGIS_PLUGIN_SUBDIR ) + '/' + *sCfgIntDir() );
-#else
-    setPluginPath( *sBuildOutputPath() + '/' + QStringLiteral( QGIS_PLUGIN_SUBDIR ) );
-#endif
-    setPkgDataPath( *sBuildOutputPath() + QStringLiteral( "/data" ) ); // in buildDir/data - used for: doc, resources, svg
-    *sLibraryPath() = *sBuildOutputPath() + '/' + QGIS_LIB_SUBDIR + '/';
-#if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
-    *sLibexecPath() = *sBuildOutputPath() + '/' + QGIS_LIBEXEC_SUBDIR + '/' + *sCfgIntDir() + '/';
-#else
-    *sLibexecPath() = *sBuildOutputPath() + '/' + QGIS_LIBEXEC_SUBDIR + '/';
-#endif
-#if defined( HAVE_QUICK )
-    *sQmlImportPath() = *sBuildOutputPath() + '/' + QGIS_QML_SUBDIR + '/';
-#endif
-  }
-  else
-  {
-    char *prefixPath = getenv( "QGIS_PREFIX_PATH" );
-    if ( !prefixPath )
-    {
-      if ( sPrefixPath()->isNull() )
-      {
-#if defined(Q_OS_MACX) || defined(Q_OS_WIN)
-        setPrefixPath( applicationDirPath(), true );
-#elif defined(ANDROID)
-        // this is "/data/data/org.qgis.qgis" in android
-        QDir myDir( QDir::homePath() );
-        myDir.cdUp();
-        QString myPrefix = myDir.absolutePath();
-        setPrefixPath( myPrefix, true );
-#else
-        QDir myDir( applicationDirPath() );
-        // Fix for server which is one level deeper in /usr/lib/cgi-bin
-        if ( applicationDirPath().contains( QStringLiteral( "cgi-bin" ) ) )
-        {
-          myDir.cdUp();
-        }
-        myDir.cdUp(); // Go from /usr/bin or /usr/lib (for server) to /usr
-        QString myPrefix = myDir.absolutePath();
-        setPrefixPath( myPrefix, true );
-#endif
-      }
-    }
-    else
-    {
-      setPrefixPath( prefixPath, true );
-    }
-  }
+//   if ( ABISYM( mRunningFromBuildDir ) )
+//   {
+//     // we run from source directory - not installed to destination (specified prefix)
+//     *sPrefixPath() = QString(); // set invalid path
+// #if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
+//     setPluginPath( *sBuildOutputPath() + '/' + QString( QGIS_PLUGIN_SUBDIR ) + '/' + *sCfgIntDir() );
+// #else
+//     setPluginPath( *sBuildOutputPath() + '/' + QStringLiteral( QGIS_PLUGIN_SUBDIR ) );
+// #endif
+//     setPkgDataPath( *sBuildOutputPath() + QStringLiteral( "/data" ) ); // in buildDir/data - used for: doc, resources, svg
+//     *sLibraryPath() = *sBuildOutputPath() + '/' + QGIS_LIB_SUBDIR + '/';
+// #if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
+//     *sLibexecPath() = *sBuildOutputPath() + '/' + QGIS_LIBEXEC_SUBDIR + '/' + *sCfgIntDir() + '/';
+// #else
+//     *sLibexecPath() = *sBuildOutputPath() + '/' + QGIS_LIBEXEC_SUBDIR + '/';
+// #endif
+// #if defined( HAVE_QUICK )
+//     *sQmlImportPath() = *sBuildOutputPath() + '/' + QGIS_QML_SUBDIR + '/';
+// #endif
+//   }
+//   else
+//   {
+//     char *prefixPath = getenv( "QGIS_PREFIX_PATH" );
+//     if ( !prefixPath )
+//     {
+//       if ( sPrefixPath()->isNull() )
+//       {
+// #if defined(Q_OS_MACX) || defined(Q_OS_WIN)
+//         setPrefixPath( applicationDirPath(), true );
+// #elif defined(ANDROID)
+//         // this is "/data/data/org.qgis.qgis" in android
+//         QDir myDir( QDir::homePath() );
+//         myDir.cdUp();
+//         QString myPrefix = myDir.absolutePath();
+//         setPrefixPath( myPrefix, true );
+// #else
+//         QDir myDir( applicationDirPath() );
+//         // Fix for server which is one level deeper in /usr/lib/cgi-bin
+//         if ( applicationDirPath().contains( QStringLiteral( "cgi-bin" ) ) )
+//         {
+//           myDir.cdUp();
+//         }
+//         myDir.cdUp(); // Go from /usr/bin or /usr/lib (for server) to /usr
+//         QString myPrefix = myDir.absolutePath();
+//         setPrefixPath( myPrefix, true );
+// #endif
+//       }
+//     }
+//     else
+//     {
+//       setPrefixPath( prefixPath, true );
+//     }
+//   }
 
   *sConfigPath() = profileFolder + '/'; // make sure trailing slash is included
   *sDefaultSvgPaths() << qgisSettingsDirPath() + QStringLiteral( "svg/" );
 
   *sAuthDbDirPath() = qgisSettingsDirPath();
-  if ( getenv( "QGIS_AUTH_DB_DIR_PATH" ) )
+  QString authDBDirPath = QString::fromLocal8Bit( qgetenv( "QGIS_AUTH_DB_DIR_PATH" ) );
+  if (!authDBDirPath.isEmpty())
   {
-    setAuthDatabaseDirPath( getenv( "QGIS_AUTH_DB_DIR_PATH" ) );
+    setAuthDatabaseDirPath( authDBDirPath );
+  }
+  else
+  {
+    setAuthDatabaseDirPath( qgisSettingsDirPath() );
   }
-
   // store system environment variables passed to application, before they are adjusted
   QMap<QString, QString> systemEnvVarMap;
   QString passfile( QStringLiteral( "QGIS_AUTH_PASSWORD_FILE" ) ); // QString, for comparison
@@ -395,14 +472,15 @@
   // append local user-writable folder as a proj search path
   QStringList currentProjSearchPaths = QgsProjUtils::searchPaths();
   currentProjSearchPaths.append( qgisSettingsDirPath() + QStringLiteral( "proj" ) );
-#ifdef Q_OS_MACX
-  // append bundled proj lib for MacOS
-  QString projLib( QDir::cleanPath( pkgDataPath().append( "/proj" ) ) );
-  if ( QFile::exists( projLib ) )
-  {
-    currentProjSearchPaths.append( projLib );
-  }
-#endif // Q_OS_MACX
+// #ifdef Q_OS_MACX
+//   // append bundled proj lib for MacOS
+//   // Library/Frameworks/proj.framework/Resources/proj
+//   QString projLib( QDir::cleanPath( pkgDataPath().append( "/proj" ) ) );
+//   if ( QFile::exists( projLib ) )
+//   {
+//     currentProjSearchPaths.append( projLib );
+//   }
+// #endif // Q_OS_MACX
 
   char **newPaths = new char *[currentProjSearchPaths.length()];
   for ( int i = 0; i < currentProjSearchPaths.count(); ++i )
@@ -415,6 +493,7 @@
     CPLFree( newPaths[i] );
   }
   delete [] newPaths;
+  qputenv("PROJ_LIB", currentProjSearchPaths[0].toUtf8());
 
   // allow Qt to search for Qt plugins (e.g. sqldrivers) in our plugin directory
   QCoreApplication::addLibraryPath( pluginPath() );
@@ -445,9 +524,12 @@
 {
   delete mDataItemProviderRegistry;
   delete mApplicationMembers;
-  delete mQgisTranslator;
-  delete mQtTranslator;
-  delete mQtBaseTranslator;
+//   delete mQgisTranslator;
+//   delete mQtTranslator;
+//   delete mQtBaseTranslator;
+  for (QTranslator *translator : mTranslators) {
+      delete translator;
+  }
 
   // we do this here as well as in exitQgis() -- it's safe to call as often as we want,
   // and there's just a *chance* that someone hasn't properly called exitQgis prior to
@@ -561,12 +643,12 @@
 void QgsApplication::setPrefixPath( const QString &prefixPath, bool useDefaultPaths )
 {
   *sPrefixPath() = prefixPath;
-#if defined(Q_OS_WIN)
-  if ( sPrefixPath()->endsWith( "/bin" ) )
-  {
-    sPrefixPath()->chop( 4 );
-  }
-#endif
+// #if defined(Q_OS_WIN)
+//   if ( sPrefixPath()->endsWith( "/bin" ) )
+//   {
+//     sPrefixPath()->chop( 4 );
+//   }
+// #endif
   if ( useDefaultPaths && !ABISYM( mRunningFromBuildDir ) )
   {
     setPluginPath( *sPrefixPath() + '/' + QStringLiteral( QGIS_PLUGIN_SUBDIR ) );
@@ -849,69 +931,94 @@
     }
   }
 
-  if ( !appPath.isNull() || getenv( "QGIS_PREFIX_PATH" ) )
-  {
-    QString prefix = getenv( "QGIS_PREFIX_PATH" ) ? getenv( "QGIS_PREFIX_PATH" ) : appPath;
-
-    // check if QGIS is run from build directory (not the install directory)
-    QFile f;
-    // "/../../.." is for Mac bundled app in build directory
-    static const QStringList paths { QStringList() << QString() << QStringLiteral( "/.." ) << QStringLiteral( "/bin" ) << QStringLiteral( "/../../.." ) };
-    for ( const QString &path : paths )
-    {
-      f.setFileName( prefix + path + "/qgisbuildpath.txt" );
-      if ( f.exists() )
-        break;
-    }
-    if ( f.exists() && f.open( QIODevice::ReadOnly ) )
-    {
-      ABISYM( mRunningFromBuildDir ) = true;
-      *sBuildSourcePath() = f.readLine().trimmed();
-      *sBuildOutputPath() = f.readLine().trimmed();
-      QgsDebugMsgLevel( QStringLiteral( "Running from build directory!" ), 4 );
-      QgsDebugMsgLevel( QStringLiteral( "- source directory: %1" ).arg( sBuildSourcePath()->toUtf8().constData() ), 4 );
-      QgsDebugMsgLevel( QStringLiteral( "- output directory of the build: %1" ).arg( sBuildOutputPath()->toUtf8().constData() ), 4 );
-#if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
-      *sCfgIntDir() = prefix.split( '/', QString::SkipEmptyParts ).last();
-      qDebug( "- cfg: %s", sCfgIntDir()->toUtf8().constData() );
-#endif
-    }
-  }
-
-  QString prefixPath;
-  if ( getenv( "QGIS_PREFIX_PATH" ) )
-    prefixPath = getenv( "QGIS_PREFIX_PATH" );
-  else
-  {
-#if defined(ANDROID)
-    // this is "/data/data/org.qgis.qgis" in android
-    QDir dir( QDir::homePath() );
-    dir.cdUp();
-    prefixPath = dir.absolutePath();
-#else
+//   if ( !appPath.isNull() || getenv( "QGIS_PREFIX_PATH" ) )
+//   {
+//     QString prefix = getenv( "QGIS_PREFIX_PATH" ) ? getenv( "QGIS_PREFIX_PATH" ) : appPath;
+
+//     // check if QGIS is run from build directory (not the install directory)
+//     QFile f;
+//     // "/../../.." is for Mac bundled app in build directory
+//     static const QStringList paths { QStringList() << QString() << QStringLiteral( "/.." ) << QStringLiteral( "/bin" ) << QStringLiteral( "/../../.." ) };
+//     for ( const QString &path : paths )
+//     {
+//       f.setFileName( prefix + path + "/qgisbuildpath.txt" );
+//       if ( f.exists() )
+//         break;
+//     }
+//     if ( f.exists() && f.open( QIODevice::ReadOnly ) )
+//     {
+//       ABISYM( mRunningFromBuildDir ) = true;
+//       *sBuildSourcePath() = f.readLine().trimmed();
+//       *sBuildOutputPath() = f.readLine().trimmed();
+//       QgsDebugMsgLevel( QStringLiteral( "Running from build directory!" ), 4 );
+//       QgsDebugMsgLevel( QStringLiteral( "- source directory: %1" ).arg( sBuildSourcePath()->toUtf8().constData() ), 4 );
+//       QgsDebugMsgLevel( QStringLiteral( "- output directory of the build: %1" ).arg( sBuildOutputPath()->toUtf8().constData() ), 4 );
+// #if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
+//       *sCfgIntDir() = prefix.split( '/', QString::SkipEmptyParts ).last();
+//       qDebug( "- cfg: %s", sCfgIntDir()->toUtf8().constData() );
+// #endif
+//     }
+//   }
+
+#ifdef Q_OS_WIN
+    QDir defaultPrefixDir(applicationDirPath() + QDir::separator() + "..");
+
+    // Add search gdal utilities paths
+    QString path = defaultPrefixDir.absolutePath();
+    qputenv("PATH", QString( "%1;%2" ).arg(path).arg(applicationDirPath()).toUtf8());
 
-#if defined(Q_OS_MACX)
-    prefixPath = appPath;
-#elif defined(Q_OS_WIN)
-    prefixPath = appPath;
-    if ( prefixPath.endsWith( "/bin" ) )
-      prefixPath.chop( 4 );
+#elif defined(Q_OS_MAC)
+    QDir defaultPrefixDir(applicationDirPath() + QDir::separator() + ".."
+                           + QDir::separator() + ".."
+                           + QDir::separator() + ".."
+                           + QDir::separator() + "..");
 #else
-    QDir dir( appPath );
-    // Fix for server which is one level deeper in /usr/lib/cgi-bin
-    if ( appPath.contains( QStringLiteral( "cgi-bin" ) ) )
-    {
-      dir.cdUp();
-    }
-    dir.cdUp(); // Go from /usr/bin or /usr/lib (for server) to /usr
-    prefixPath = dir.absolutePath();
-#endif
+    QDir defaultPrefixDir("/usr");
 #endif
-  }
+    QString defaultPrefixPath =  defaultPrefixDir.absolutePath();
 
-  if ( ABISYM( mRunningFromBuildDir ) )
-    return *sBuildOutputPath() + QStringLiteral( "/data" );
-  else
+    QString envPrefixPath = QString::fromLocal8Bit( qgetenv( "QGIS_PREFIX_PATH" ) );
+    QString prefixPath( envPrefixPath.isEmpty() ?
+                            defaultPrefixPath : envPrefixPath );
+    QgsDebugMsg( QString( "prefixPath(): %1" ).arg( prefixPath ) );
+
+
+//   if ( getenv( "QGIS_PREFIX_PATH" ) )
+//     prefixPath = getenv( "QGIS_PREFIX_PATH" );
+//   else
+//   {
+// #if defined(ANDROID)
+//     // this is "/data/data/org.qgis.qgis" in android
+//     QDir dir( QDir::homePath() );
+//     dir.cdUp();
+//     prefixPath = dir.absolutePath();
+// #else
+
+// #if defined(Q_OS_MACX)
+//     prefixPath = appPath;
+// #elif defined(Q_OS_WIN)
+//     prefixPath = appPath;
+//     if ( prefixPath.endsWith( "/bin" ) )
+//       prefixPath.chop( 4 );
+// #else
+//     QDir dir( appPath );
+//     // Fix for server which is one level deeper in /usr/lib/cgi-bin
+//     if ( appPath.contains( QStringLiteral( "cgi-bin" ) ) )
+//     {
+//       dir.cdUp();
+//     }
+//     dir.cdUp(); // Go from /usr/bin or /usr/lib (for server) to /usr
+//     prefixPath = dir.absolutePath();
+// #endif
+// #endif
+//   }
+
+    setPrefixPath( prefixPath, true );
+    qputenv("QGIS_PREFIX_PATH", prefixPath.toUtf8());
+
+//   if ( ABISYM( mRunningFromBuildDir ) )
+//     return *sBuildOutputPath() + QStringLiteral( "/data" );
+//   else
     return prefixPath + '/' + QStringLiteral( QGIS_DATA_SUBDIR );
 }
 
@@ -1070,9 +1177,9 @@
 
 QString QgsApplication::i18nPath()
 {
-  if ( ABISYM( mRunningFromBuildDir ) )
-    return *sBuildOutputPath() + QStringLiteral( "/i18n/" );
-  else
+//   if ( ABISYM( mRunningFromBuildDir ) )
+//     return *sBuildOutputPath() + QStringLiteral( "/i18n/" );
+//   else
     return pkgDataPath() + QStringLiteral( "/i18n/" );
 }
 
@@ -1113,25 +1220,25 @@
 
 QString QgsApplication::srsDatabaseFilePath()
 {
-  if ( ABISYM( mRunningFromBuildDir ) )
-  {
-    QString tempCopy = QDir::tempPath() + "/srs6.db";
-
-    if ( !QFile( tempCopy ).exists() )
-    {
-      QFile f( buildSourcePath() + "/resources/srs6.db" );
-      if ( !f.copy( tempCopy ) )
-      {
-        qFatal( "Could not create temporary copy" );
-      }
-    }
-
-    return tempCopy;
-  }
-  else
-  {
+//   if ( ABISYM( mRunningFromBuildDir ) )
+//   {
+//     QString tempCopy = QDir::tempPath() + "/srs6.db";
+
+//     if ( !QFile( tempCopy ).exists() )
+//     {
+//       QFile f( buildSourcePath() + "/resources/srs6.db" );
+//       if ( !f.copy( tempCopy ) )
+//       {
+//         qFatal( "Could not create temporary copy" );
+//       }
+//     }
+
+//     return tempCopy;
+//   }
+//   else
+//   {
     return pkgDataPath() + QStringLiteral( "/resources/srs.db" );
-  }
+//   }
 }
 
 void QgsApplication::setSvgPaths( const QStringList &svgPaths )
@@ -1224,12 +1331,12 @@
     return *sUserName();
 
   //backup plan - use environment variables
-  *sUserName() = qgetenv( "USER" );
+  *sUserName() = QString::fromLocal8Bit(qgetenv( "USER" ));
   if ( !sUserName()->isEmpty() )
     return *sUserName();
 
   //last resort
-  *sUserName() = qgetenv( "USERNAME" );
+  *sUserName() = QString::fromLocal8Bit(qgetenv( "USERNAME" ));
   return *sUserName();
 }
 
@@ -1251,8 +1358,8 @@
   //fall back to login name
   if ( sUserFullName()->isEmpty() )
     *sUserFullName() = userLoginName();
-#elif defined(Q_OS_ANDROID) || defined(__MINGW32__)
-  *sUserFullName() = QStringLiteral( "Not available" );
+// #elif defined(Q_OS_ANDROID) || defined(__MINGW32__)
+//   *sUserFullName() = QStringLiteral( "Not available" );
 #else
   struct passwd *p = getpwuid( getuid() );
 
@@ -1443,28 +1550,36 @@
 
 QString QgsApplication::showSettings()
 {
-  QString myEnvironmentVar( getenv( "QGIS_PREFIX_PATH" ) );
+  QString myEnvironmentVar = QString::fromLocal8Bit(qgetenv( "QGIS_PREFIX_PATH" ) );
   QString myState = tr( "Application state:\n"
                         "QGIS_PREFIX_PATH env var:\t\t%1\n"
                         "Prefix:\t\t%2\n"
-                        "Plugin Path:\t\t%3\n"
-                        "Package Data Path:\t%4\n"
-                        "Active Theme Name:\t%5\n"
-                        "Active Theme Path:\t%6\n"
-                        "Default Theme Path:\t%7\n"
-                        "SVG Search Paths:\t%8\n"
-                        "User DB Path:\t%9\n"
-                        "Auth DB Path:\t%10\n" )
+                        "Library Path:\t\t%3\n"
+                        "Plugin Path:\t\t%4\n"
+                        "Package Data Path:\t%5\n"
+                        "Active Theme Name:\t%6\n"
+                        "Active Theme Path:\t%7\n"
+                        "Default Theme Path:\t%8\n"
+                        "SVG Search Paths:\t%9\n"
+                        "User DB Path:\t%10\n"
+                        "Auth DB Path:\t%11\n"
+                        "Translations Path:\t%12\n"
+                        "SRS DB Path:\t%13\n"
+                        "Icons Path:\t%14\n"  )
                     .arg( myEnvironmentVar,
                           prefixPath(),
+                          libraryPath(),
                           pluginPath(),
                           pkgDataPath(),
                           themeName(),
                           activeThemePath(),
                           defaultThemePath(),
-                          svgPaths().join( tr( "\n\t\t", "match indentation of application state" ) ),
-                          qgisMasterDatabaseFilePath() )
-                    .arg( qgisAuthDatabaseFilePath() );
+                          svgPaths().join( tr( "\n\t\t", "match indentation of application state" ) ) )
+                    .arg( qgisMasterDatabaseFilePath(),
+                          qgisAuthDatabaseFilePath(), 
+                          i18nPath(),
+                          srsDatabaseFilePath(),
+                          iconsPath() );
   return myState;
 }
 
@@ -1752,22 +1867,22 @@
   return targetElems.join( QLatin1Char( '/' ) );
 }
 
-QString QgsApplication::buildSourcePath()
-{
-  return *sBuildSourcePath();
-}
-
-QString QgsApplication::buildOutputPath()
-{
-  return *sBuildOutputPath();
-}
-
-#if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
-QString QgsApplication::cfgIntDir()
-{
-  return *sCfgIntDir();
-}
-#endif
+// QString QgsApplication::buildSourcePath()
+// {
+//   return *sBuildSourcePath();
+// }
+
+// QString QgsApplication::buildOutputPath()
+// {
+//   return *sBuildOutputPath();
+// }
+
+// #if defined(_MSC_VER) && !defined(USING_NMAKE) && !defined(USING_NINJA)
+// QString QgsApplication::cfgIntDir()
+// {
+//   return *sCfgIntDir();
+// }
+// #endif
 
 void QgsApplication::skipGdalDriver( const QString &driver )
 {
@@ -1974,7 +2089,7 @@
   ApplicationMembers *appMembers = members();
   if ( appMembers->mNullRepresentation.isNull() )
   {
-    appMembers->mNullRepresentation = QgsSettings().value( QStringLiteral( "qgis/nullValue" ), QStringLiteral( "NULL" ) ).toString();
+    appMembers->mNullRepresentation = QgsSettings().value( QStringLiteral( "qgis/nullValue" ), QStringLiteral( "<NULL>" ) ).toString();
   }
   return appMembers->mNullRepresentation;
 }
@@ -2015,8 +2130,7 @@
 #else
   //under other OS's we use an environment var so the user can
   //override the path if he likes
-  int myChangeFlag = 0; //whether we want to force the env var to change
-  setenv( "GDAL_PAM_PROXY_DIR", myPamPath.toUtf8(), myChangeFlag );
+  qputenv( "GDAL_PAM_PROXY_DIR", myPamPath.toUtf8() );
 #endif
 
   // Check qgis.db and make private copy if necessary
@@ -2356,15 +2470,15 @@
   return members()->mAnnotationItemRegistry;
 }
 
-QgsGpsConnectionRegistry *QgsApplication::gpsConnectionRegistry()
-{
-  return members()->mGpsConnectionRegistry;
-}
-
-QgsBabelFormatRegistry *QgsApplication::gpsBabelFormatRegistry()
-{
-  return members()->mGpsBabelFormatRegistry;
-}
+// QgsGpsConnectionRegistry *QgsApplication::gpsConnectionRegistry()
+// {
+//   return members()->mGpsConnectionRegistry;
+// }
+
+// QgsBabelFormatRegistry *QgsApplication::gpsBabelFormatRegistry()
+// {
+//   return members()->mGpsBabelFormatRegistry;
+// }
 
 QgsPluginLayerRegistry *QgsApplication::pluginLayerRegistry()
 {
@@ -2451,10 +2565,10 @@
   return members()->mProjectStorageRegistry.get();
 }
 
-QgsExternalStorageRegistry *QgsApplication::externalStorageRegistry()
-{
-  return members()->mExternalStorageRegistry;
-}
+// QgsExternalStorageRegistry *QgsApplication::externalStorageRegistry()
+// {
+//   return members()->mExternalStorageRegistry;
+// }
 
 QgsLocalizedDataPathRegistry *QgsApplication::localizedDataPathRegistry()
 {
@@ -2555,16 +2669,16 @@
     mPointCloudRendererRegistry = new QgsPointCloudRendererRegistry();
     profiler->end();
   }
-  {
-    profiler->start( tr( "Setup GPS registry" ) );
-    mGpsConnectionRegistry = new QgsGpsConnectionRegistry();
-    profiler->end();
-  }
-  {
-    profiler->start( tr( "Setup GPSBabel format registry" ) );
-    mGpsBabelFormatRegistry = new QgsBabelFormatRegistry();
-    profiler->end();
-  }
+//   {
+//     profiler->start( tr( "Setup GPS registry" ) );
+//     mGpsConnectionRegistry = new QgsGpsConnectionRegistry();
+//     profiler->end();
+//   }
+//   {
+//     profiler->start( tr( "Setup GPSBabel format registry" ) );
+//     mGpsBabelFormatRegistry = new QgsBabelFormatRegistry();
+//     profiler->end();
+//   }
   {
     profiler->start( tr( "Setup plugin layer registry" ) );
     mPluginLayerRegistry = new QgsPluginLayerRegistry();
@@ -2608,11 +2722,11 @@
     mProjectStorageRegistry.reset( new QgsProjectStorageRegistry() );
     profiler->end();
   }
-  {
-    profiler->start( tr( "Setup external storage registry" ) );
-    mExternalStorageRegistry = new QgsExternalStorageRegistry();
-    profiler->end();
-  }
+//   {
+//     profiler->start( tr( "Setup external storage registry" ) );
+//     mExternalStorageRegistry = new QgsExternalStorageRegistry();
+//     profiler->end();
+//   }
   {
     profiler->start( tr( "Setup network content cache" ) );
     mNetworkContentFetcherRegistry = new QgsNetworkContentFetcherRegistry();
@@ -2657,8 +2771,8 @@
   delete mAnnotationRegistry;
   delete mColorSchemeRegistry;
   delete mFieldFormatterRegistry;
-  delete mGpsConnectionRegistry;
-  delete mGpsBabelFormatRegistry;
+//   delete mGpsConnectionRegistry;
+//   delete mGpsBabelFormatRegistry;
   delete mMessageLog;
   delete mPaintEffectRegistry;
   delete mPluginLayerRegistry;
@@ -2675,7 +2789,7 @@
   delete mCalloutRegistry;
   delete mRecentStyleHandler;
   delete mSymbolLayerRegistry;
-  delete mExternalStorageRegistry;
+//   delete mExternalStorageRegistry;
   delete mTaskManager;
   delete mNetworkContentFetcherRegistry;
   delete mClassificationMethodRegistry;
@@ -2706,3 +2820,8 @@
     return sApplicationMembers;
   }
 }
+
+QString QgsApplication::fontsPath()
+{
+    return pkgDataPath() + QDir::separator() + QStringLiteral( "fonts" );
+}
\ No newline at end of file
